# path: backend/app/api/v1/environmental.py

from fastapi import APIRouter, HTTPException, Request
import asyncpg
import os
import json
import asyncio
from datetime import datetime

router = APIRouter()

# ----------------------------------------------------------------------
# 1️⃣  STATUS — From running Environmental Agent (in backend main)
# ----------------------------------------------------------------------
@router.get("/status")
async def get_environmental_agent_status(request: Request):
    """Return environmental agent monitoring status."""
    agent = getattr(request.app.state, "environmental_agent", None)

    if agent is None:
        raise HTTPException(status_code=503, detail="Environmental Agent not initialized")

    return agent.get_status()


# ----------------------------------------------------------------------
# 2️⃣  OUTPUT — Latest Predictions + Alerts
# ----------------------------------------------------------------------
@router.get("/output")
async def get_environmental_output(request: Request):
    """Return latest output generated by the environmental agent."""
    agent = getattr(request.app.state, "environmental_agent", None)

    if agent is None:
        raise HTTPException(status_code=503, detail="Environmental Agent not initialized")

    if agent.latest_output is None:
        raise HTTPException(status_code=404, detail="No predictions available yet")

    return agent.latest_output


# ----------------------------------------------------------------------
# 3️⃣  MANUAL TRIGGER — Run monitoring cycle on-demand
# ----------------------------------------------------------------------
@router.post("/trigger")
async def trigger_monitoring_cycle(request: Request):
    """Trigger a new monitoring cycle manually."""
    agent = getattr(request.app.state, "environmental_agent", None)

    if agent is None:
        raise HTTPException(status_code=503, detail="Environmental Agent not initialized")

    async def run_cycle_and_update():
        try:
            await agent.run_monitoring_cycle()
        except Exception as e:
            print("Monitoring cycle failed:", e)

    asyncio.create_task(run_cycle_and_update())

    return {"message": "Monitoring cycle started", "status": "running"}

# ----------------------------------------------------------------------
# 4️⃣  HISTORICAL DB PREDICTIONS (your original route, kept)
# ----------------------------------------------------------------------

DATABASE_URL = os.getenv(
    "ENV_DB_URL",
    "postgresql://postgres:postgres@db:5432/disaster_db"
)

QUERY = """
    SELECT 
        fp.timestamp,
        sz.name AS zone,
        ST_Y(sz.center::geometry) AS latitude,
        ST_X(sz.center::geometry) AS longitude,
        fp.risk_score,
        fp.severity_level,
        fp.confidence,
        fp.time_to_impact_hours,
        fp.affected_area_km2,
        fp.risk_factors,
        fp.recommended_actions
    FROM flood_predictions fp
    JOIN sentinel_zones sz ON fp.zone_id = sz.id
    ORDER BY fp.timestamp DESC
    LIMIT $1;
"""

def json_serial(obj):
    """Serializer for datetime objects."""
    if isinstance(obj, datetime):
        return obj.isoformat()
    raise TypeError("Type not serializable")

@router.get("/predictions")
async def get_environmental_predictions(limit: int = 20):
    """Return latest flood predictions from database (historical data)."""
    try:
        conn = await asyncpg.connect(DATABASE_URL)
        rows = await conn.fetch(QUERY, limit)
        await conn.close()

        predictions = []
        for row in rows:
            r = dict(row)

            # Parse JSON fields
            rf = r.get("risk_factors")
            if isinstance(rf, (str, bytes)):
                try:
                    r["risk_factors"] = json.loads(rf)
                except:
                    r["risk_factors"] = {}


            if isinstance(r.get("recommended_actions"), str):
                try:
                    r["recommended_actions"] = json.loads(r["recommended_actions"])
                except json.JSONDecodeError:
                    pass

            predictions.append(r)

        return {"count": len(predictions), "predictions": predictions}

    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
